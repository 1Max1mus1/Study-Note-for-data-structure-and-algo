# 二分查找

# 整数二分算法详解

## 1. 二分查找的基本思想

二分查找是一种在**有序数组**中高效查找目标值的算法。其核心思想是：

- 每次将搜索范围缩小一半
- 通过比较中间元素与目标值的大小关系来决定搜索方向
- 时间复杂度：O(log n)

### 基本原理图示

```
有序数组: [1, 2, 2, 2, 3, 4, 5]
索引:      0  1  2  3  4  5  6

查找目标值 x = 2：
第1步: l=0, r=6, mid=3, a[3]=2
第2步: 根据条件判断，调整 l 或 r
第3步: 继续缩小范围...

```

## 2. 整数二分的两种模板

### 模板1：查找左边界（第一个满足条件的位置）

```cpp
int l = 0, r = n - 1;
while (l < r) {
    int mid = (l + r) >> 1;  // 等同于 (l + r) / 2
    if (check(mid)) r = mid;     // 满足条件，答案在左半部分（包含mid）
    else l = mid + 1;            // 不满足条件，答案在右半部分
}
// 结果：l 就是答案

```

### 模板2：查找右边界（最后一个满足条件的位置）

```cpp
int l = 0, r = n;  // 注意：r 初始化为 n
while (l + 1 < r) {
    int mid = (l + r) >> 1;
    if (check(mid)) l = mid;     // 满足条件，答案在右半部分（包含mid）
    else r = mid;                // 不满足条件，答案在左半部分
}
// 结果：l 就是答案

```

## 3. 代码详细分析

让我们分析你提供的代码，它要解决的问题是：
**在有序数组中找到目标值 x 的第一个和最后一个出现位置**

### 第一次二分：找左边界（第一个等于x的位置）

```cpp
int l=0,r=n-1;
while(l<r){
    int mid = l + r >> 1;
    if (a[mid] >= x) r = mid;    // 关键：>=
    else l = mid + 1;
}

```

**逻辑分析：**

- **目标**：找到第一个 >= x 的位置
- **条件判断**：`a[mid] >= x`
    - 如果 `a[mid] >= x`：说明第一个 >= x 的位置在 mid 或 mid 左边，所以 `r = mid`
    - 如果 `a[mid] < x`：说明第一个 >= x 的位置在 mid 右边，所以 `l = mid + 1`

### 第二次二分：找右边界（最后一个等于x的位置）

```cpp
int l1=l,r1=n;
while(l1+1<r1){
    int mid = l1 + r1 >> 1;
    if (a[mid] <= x) l1 = mid;   // 关键：<=
    else r1 = mid;
}

```

**逻辑分析：**

- **目标**：找到最后一个 <= x 的位置
- **条件判断**：`a[mid] <= x`
    - 如果 `a[mid] <= x`：说明最后一个 <= x 的位置在 mid 或 mid 右边，所以 `l1 = mid`
    - 如果 `a[mid] > x`：说明最后一个 <= x 的位置在 mid 左边，所以 `r1 = mid`

## 4. 完整执行过程示例

### 输入数据

```
数组: [1, 2, 2, 2, 3, 4]
索引:  0  1  2  3  4  5
查找: x = 2

```

### 第一次二分（找左边界）

| 步骤 | l | r | mid | a[mid] | a[mid] >= 2? | 操作 |
| --- | --- | --- | --- | --- | --- | --- |
| 初始 | 0 | 5 | - | - | - | - |
| 1 | 0 | 5 | 2 | 2 | 是 | r = 2 |
| 2 | 0 | 2 | 1 | 2 | 是 | r = 1 |
| 3 | 0 | 1 | 0 | 1 | 否 | l = 1 |
| 结束 | 1 | 1 | - | - | - | l = 1 |

**结果：第一个等于2的位置是索引1**

### 检查是否存在

```cpp
if(a[l]!=x){
    printf("-1 -1\n");
    continue;
}

```

a[1] = 2 = x，所以目标值存在。

### 第二次二分（找右边界）

| 步骤 | l1 | r1 | mid | a[mid] | a[mid] <= 2? | 操作 |
| --- | --- | --- | --- | --- | --- | --- |
| 初始 | 1 | 6 | - | - | - | - |
| 1 | 1 | 6 | 3 | 2 | 是 | l1 = 3 |
| 2 | 3 | 6 | 4 | 3 | 否 | r1 = 4 |
| 结束 | 3 | 4 | - | - | - | l1 = 3 |

**结果：最后一个等于2的位置是索引3**

### 最终输出

实际上最终输出应该是：

```
1 3

```

表示目标值2在索引1到3的范围内。

## 5. 关键要点总结

### 边界处理

1. **左边界模板**：`r = n-1`，循环条件 `l < r`
2. **右边界模板**：`r = n`，循环条件 `l+1 < r`

### 中点计算

```cpp
int mid = (l + r) >> 1;  // 右移1位等于除以2，但更高效

```

### 条件设置

- **找第一个满足条件的**：`if (满足条件) r = mid; else l = mid + 1;`
- **找最后一个满足条件的**：`if (满足条件) l = mid; else r = mid;`

### 防止死循环

- 模板1：使用 `l < r` 和 `l = mid + 1`
- 模板2：使用 `l + 1 < r` 和正确的边界更新

## 6. 算法优势

1. **时间复杂度**：O(log n)，远优于线性查找的O(n)
2. **空间复杂度**：O(1)，只使用常数额外空间
3. **适用性强**：不仅限于查找确切值，还可以查找边界、插入位置等

## 7. 常见应用场景

- 在有序数组中查找元素
- 查找插入位置
- 查找第一个/最后一个满足条件的元素
- 求解单调函数的零点
- 最优化问题中的参数搜索



## 8.**代码实操练习**

**整数二分**

```
#include <iostream>

using namespace std;

const int N = 100005;
int n,q,x;
int a[N];

int main(){
    scanf("%d%d",&n, &q);
    for(int i =0;i<n;i++) scanf("%d",&a[i]);
    while(q--){
        scanf("%d",&x);
        int l=0,r=n-1;
        while(l<r){
            int mid = l + r  >> 1;
            if (a[mid] >= x) r = mid;
            else l = mid + 1;
        }
        if(a[l]!=x){
            printf("-1 -1\n");
            continue;
        }
        int l1=l,r1=n;
        while(l1+1<r1){
            int mid = l1 + r1 >> 1;
            if (a[mid] <= x) l1 = mid;
            else r1 = mid;
        }
        printf("%d %d\n", l, l1);
    }
    return 0;
}

语言：C++
作者：8Bit.E
链接：https://www.acwing.com/activity/content/code/content/9716332/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

